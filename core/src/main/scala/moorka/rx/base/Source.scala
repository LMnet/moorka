package moorka.rx.base

import moorka.rx.base.bindings.Binding

import scala.collection.mutable
import scala.ref.WeakReference

/**
 * @author Aleksey Fomkin <aleksey.fomkin@gmail.com>
 */
trait Source[A] extends Rx[A] {

  private var _alive = true
  
  def alive = _alive

  /**
   * List of bindings generated by this source. When updated fired
   * all bindings will get a new value
   * @see [[flatMap]]
   */
  private[rx] var bindings = List.empty[WeakReference[Binding[A, _]]]

  /**
   * List of values this source depends on.
   */
  private[rx] var upstreams = List.empty[Rx[_]]

  /**
   * Remove references to all upstreams that are not alive.
   */
  private[rx] def cleanupUpstreams() = {
    upstreams = upstreams.filter(_.alive)
  }

  private[rx] def addUpstream(x: Rx[_]): Unit = {
    upstreams ::= x
  }

  /**
   * Broadcast `v` to bindings. Removes bindings dropped by GC.
   * @param v new value
   */
  private[rx] def update(v: A): Unit = {
    bindings foreach { x ⇒
      x.get match {
        case Some(f) ⇒ f.run(v)
        case None ⇒
      }
    }
    bindings = bindings filter { x ⇒
      x.get match {
        case Some(_) ⇒ true
        case None ⇒ false
      }
    }
  }

  private[rx] def attachBinding(ref: WeakReference[Binding[A, _]]) = {
    bindings ::= ref
  }

  private[rx] def detachBinding(ref: WeakReference[Binding[A, _]]) = {
    bindings = bindings.filter(_ != ref)
  }

  @deprecated("Use pull() instead emit()", "0.4.0")
  def emit(v: A): Unit = {
    update(v)
  }

  @inline def <<=(rx: Rx[A]) = pull(rx)

  def pull(rx: Rx[A]) = rx match {
    case Val(x) ⇒
      update(x)
    case Killer ⇒
      kill()
    case Dummy ⇒
    // Do nothing
    case upstream ⇒
      addUpstream {
        upstream foreach update
      }
  }

  def flatMap[B](f: A ⇒ Rx[B]): Rx[B]

  def kill() = {
    _alive = false
    bindings = Nil
    upstreams.foreach(_.kill())
    upstreams = Nil
  }
}

trait StatefulSource[A] extends Source[A]
