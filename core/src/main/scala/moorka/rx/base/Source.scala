package moorka.rx.base

import moorka.rx.base.bindings.Binding

/**
 * @author Aleksey Fomkin <aleksey.fomkin@gmail.com>
 */
trait Source[A] extends Rx[A] {

  private var _alive = true

  def alive = _alive

  /**
   * List of bindings generated by this source. When updated fired
   * all bindings will get a new value
   * @see [[flatMap]]
   */
  private[rx] var bindings = List.empty[Binding[A, _]]

  /**
   * List of values this source depends on.
   */
  private[rx] var upstreams = List.empty[Rx[_]]

  /**
   * Remove references to all upstreams that are not alive.
   */
  private[rx] def cleanupUpstreams() = {
    upstreams = upstreams.filter(_.alive)
  }

  private[rx] def addUpstream(x: Rx[_]): Unit = {
    upstreams ::= x
  }

  private[rx] def killUpstreams() = {
    upstreams.foreach(_.kill())
    upstreams = Nil
  }

  /**
   * Broadcast `v` to bindings. Removes bindings dropped by GC.
   * @param v new value
   */
  private[rx] def update(v: A): Unit = {
    bindings.foreach(_.run(v))
  }

  private[rx] def attachBinding(b: Binding[A, _]) = {
    bindings ::= b
  }

  private[rx] def detachBinding(b: Binding[A, _]) = {
    bindings = bindings.filter(_ != b)
  }

  @inline def <<=(rx: Rx[A]) = pull(rx)

  def pull(rx: Rx[A]) = rx match {
    case Val(x) ⇒
      update(x)
    case Killer ⇒
      kill()
    case Dummy ⇒
    // Do nothing
    case upstream ⇒
      addUpstream {
        upstream foreach update
      }
  }

  def pullOnce(rx: Rx[A]) = rx once { data ⇒
    update(data)
  }

  def flatMap[B](f: A ⇒ Rx[B]): Rx[B]

  def kill() = {
    _alive = false
    bindings = Nil
    killUpstreams()
  }
}

trait StatefulSource[A] extends Source[A]
