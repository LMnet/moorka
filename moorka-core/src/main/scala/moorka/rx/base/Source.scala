package moorka.rx.base

import moorka.rx.base.bindings.Binding

import scala.ref.WeakReference

/**
 * @author Aleksey Fomkin <aleksey.fomkin@gmail.com>
 */
trait Source[A] extends Rx[A] {

  /**
   * List of bindings generated by this source. When updated fired
   * all bindings will get a new value
   * @see [[flatMap]]
   */
  private[rx] var bindings: List[WeakReference[Binding[A, _]]] = Nil

  /**
   * List of values this source depends on.
   */
  private[rx] var upstreams: List[Rx[_]] = Nil

  /**
   * Broadcast `v` to bindings. Removes bindings dropped by GC.
   * @param v new value
   */
  private[rx] def update(v: A): Unit = {
    bindings foreach { x ⇒
      x.get match {
        case Some(f) ⇒ f.run(v)
        case None ⇒
      }
    }
    bindings = bindings filter { x ⇒
      x.get match {
        case Some(_) ⇒ true
        case None ⇒ false
      }
    }
  }

  private[rx] def attachBinding(ref: WeakReference[Binding[A, _]]) = {
    bindings ::= ref
  }

  private[rx] def detachBinding(ref: WeakReference[Binding[A, _]]) = {
    bindings = bindings.filter(_ != ref)
  }

  @deprecated("Use pull() instead emit()", "0.4.0")
  def emit(v: A): Unit = {
    update(v)
  }

  @inline def <<=(rx: Rx[A]) = pull(rx)

  def pull(rx: Rx[A]) = rx match {
    case Val(x) ⇒
      update(x)
    case Killer ⇒
      kill()
    case Dummy ⇒
    // Do nothing
    case upstream ⇒
      upstreams ::= upstream foreach update
  }

  def flatMap[B](f: A ⇒ Rx[B]): Rx[B]

  def kill() = {
    bindings = Nil
    upstreams.foreach(_.kill())
    upstreams = Nil
  }
}
